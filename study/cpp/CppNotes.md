# C++简明衔接概念&C语言的补充概念

## 编程步骤

1. 编写源代码；2. 预处理；3. 编译；4. 链接；5. 加载；6. 运行  
![编程步骤](..\code_picture\编程步骤.png)

## cout&cin进行C++输出&输入

从概念上看，输出是一个流，即从程序输出的一系列字符。`cout`对象表示这种流，其属性是在`iostream`中定义的。
`cout << "Hello World!" << endl;`*（消息语句：将消息发送给对象，激发某种行为）*它将字符串插入到`cout`流中，`endl`表示换行符，`<<`是插入运算符，它将字符串插入到`cout`流中。`<<`指出了**信息的流动路径**，即信息从字符串流向`cout`，相应的，`>>`是提取运算符，它将信息从`cin`流向变量。

> ***初始运算符重载***：通过重载，同一个运算符将有不同的含义，编译器通过上下文来确定运算符的含义。*如&运算符，可以表示取地址，也可以表示按位与。*  
> C++扩展了运算符重载的概念，允许为用户定义的类型重新定义运算符的含义。

### 典型的整型溢出行为

![典型的整型溢出行为](..\code_picture\典型的整型溢出行为.png)

### cin的类型不匹配情况

```c++
int n;
cin >> n;
```

如果用户输入一个单词而不是一个数字：

- n的值保持不变；
- 不匹配的输入会被留在输入队列中，下一次读取将继续读取这个单词；
- cin对象中的一个错误标记被设置；
- 对cin方法的调用将返回false(如果被转换为bool类型)。

### 文本I/O和文本文件

使用cin输入时，程序将输入视为**一系列的字节**，其中每个字节都被解释为**字符编码**。不管目标数据类型是什么，输入一开始都是字符数据————文本数据。然后cin将这些字符转换为目标类型的值。  
假设有如下输入行：38.5 19.2

```c++
char ch;
cin >> ch;
```

输入行中第一个字符被赋给ch，即字符3。输入和目标变量都是字符(ASCII)，不需要进行转换。输入队列下一个字符为字符8。

```c++
int n;
cin >> n;
```

cin将不断读取，直到遇到**非数字字符**，即它将读取38，然后将其转换为整数38。输入队列下一个字符为‘.’。

```c++
double x;
cin >> x;
```

cin将不断读取，直到遇到**第一个不属于浮点数的字符**，即它将读取38.5，然后将其转换为浮点数38.5，再把38.5的二进制编码(浮点格式)复制到变量x中。输入队列下一个字符为空格。

```c++
char word[20];
cin >> word;
```

cin将不断读取，直到遇到**空白字符**，即它将读取38.5，再把字符串的字符编码复制到数组word中，并再末尾加上`\0`。输入队列下一个字符为空格。

```c++
char word[20];
cin.get(word,20);
```

`cin`将不断读取，直到遇到**换行符**，即它将读取38.5 19.2，再把字符串的字符编码复制到数组word中，并再末尾加上`\0`。换行符被丢弃，输入队列下一个字符为下一行的第一个字符。这里不需要转换，因为输入和目标变量都是字符(ASCII)。

---

对于输入则执行相反的操作，即将值转换为字符编码，然后将字符编码写入输出流。

## 类简介

- 类是用户自定义的数据类型，它是数据和操作数据的函数的集合。
- 类之于对象就像类型之于变量。**即类是对象的抽象，对象是类的实例。** *类好比所有著名的演员，而对象好比某个著名的演员，而表示演员的类中包括该类可执行的操作的定义，如念台词、表达情绪等*。  

创建一个`int`类型的变量carrots，也就是说carrots可以存储整数，可以按照特定的方式使用，比如加和减。`cout`是一个`ostream`类的对象，ostream的类定义(iostream文件的另一个成员)描述了ostream对象表示的数据以及可以对它执行的操作，如将数字或字符串插入到输出流中。  
***注意：类描述了一种数据类型的全部属性（包括可使用它执行的操作），对象是根据这些描述创建的实体。***

> 类—汽车的设计图纸  
实例化（对象）—生产出的汽车  
停车场—计算机的存储  
停车场编号—内存的地址  
类是用来描述实例的，实例是类的具体结果  
面向对象的三大特征：  
封装—类的集合  
继承—通用的标准 车轮 方向盘等  
多态—各式各样的小汽车🚙🚗🚕🚌🚎🚓

![向对象发送消息](..\code_picture\向对象发送消息.png)

## 多函数程序中使用using编译指令

- 将`using namespace std;`放在函数定义之前，让文件中所有的函数都能使用名称空间std中所有的元素。
- 将`using namespace std;`放在特定的函数定义中，让该函数能够使用名称空间std中所有的元素。
- 在特定的函数中使用类似`using std::cout;`的编译指令，而不是`using namespace std;`，让该函数能够使用指定的元素。
- 完全不使用编译指令`using`，而在需要使用名称空间std中的元素时，使用前缀std::。

### 关于冲突问题

- `using std::cout;`：这是一个 ***使用声明*** ，它告诉编译器在后续的代码中，如果遇到cout，就应该理解为std::cout。这样，你就可以在后续的代码中直接使用cout，而不需要每次都写出std::cout。*这种方式可以减少代码的冗余，但是如果在同一个作用域中有其他的cout（例如，你自己定义的变量或函数），就可能导致命名冲突*。

- `std::cout`：这是对cout的 ***完全限定名*** 的使用。std::cout是在std命名空间中定义的一个对象，用于向标准输出（通常是控制台）写入数据。每次使用std::cout都需要写出std::前缀，*这样可以避免命名冲突，但是会增加代码的冗余。*

```c++
#include <iostream>
int main()
{
    using std::cout;
    int cout = 5;
    cout << cout << endl;//会产生冲突
    return 0;
}
```

```c++
#include <iostream>
int main()
{
    int cout = 5;
    std::cout << cout << endl;//不会产生冲突
    return 0;
}
```

## C++如何确定auto常量的类型

对于整数，除非有理由存储为其他类型，否则C++将其存储为`int`类型。对于浮点数，除非有理由存储为其他类型，否则C++将其存储为`double`类型。

```c++
auto i = 10; // 这里的i会被C++存储为int类型
auto d = 10.0; // 这里的d会被C++存储为double类型
```

- 后缀：放在数字后面表示类型的字母；
  
  > `ULL`：无符号长长整型     `UL`：无符号长整型     `U`：无符号整型  
    > `LL`：长长整型     `L`：长整型     `F`：单精度浮点型     `L`：长双精度浮点型(具体含义取决于前面的数字是整数还是浮点数)
- 对于不带后缀的十进制整数，将使用下面几种类型中能够**存储该数的最小类型**：`int`、`long`、`long long`。
- 对于不带后缀的八进制或十六进制整数，将使用下面几种类型中能够**存储该数的最小类型**：`int`、`unsigned int`、`long`、`unsigned long`、`long long`、`unsigned long long`。（十六进制数经常被表示为地址，而地址没有符号，因此`unsigned`比`long`更适合用来表示16位的地址）

## 通用字符名与宽字符类型

### 通用字符名

- 通用字符名（Universal Character Names，UCN）是C++和C语言中的一个特性，允许你使用Unicode字符集中的任何字符。这些字符可以直接在字符串和字符字面量中使用，也可以通过其对应的UCN（形式为\uNNNN或\UNNNNNNNN）使用，其中N是十六进制数字。

- 其用法与转义序列类似，通用字符名以\u或\U开头，*\u后面是8个十六进制位，\U后面则是16个十六进制位*。这些位表示的是字符的ISO 10646码点.
  
```C++
#include <iostream>
int main()
{
    std::cout << "\u00e5" << std::endl;//输出å
}
```

> ***Unicode***：Unicode是一个字符集，为世界上的每种语言的每个字符分配了一个唯一的数字，称为码点。Unicode可以容纳超过一百万个字符，覆盖了世界上几乎所有的书写系统。  
> ***UTF-8***：UTF-8是一种将Unicode码点编码为字节序列的方法。它是一种变长编码，每个字符可以由1到4个字节表示。UTF-8与ASCII兼容，即ASCII字符在UTF-8编码中仍然是单字节，并且字节值与ASCII编码相同。  
> ***ASCII***：ASCII是一种字符编码标准，只能表示基本的拉丁字母、数字和符号。ASCII是7位编码，只能表示128个不同的字符。ASCII是Unicode和UTF-8的一个子集，也就是说，ASCII字符在Unicode和UTF-8中的表示方式与ASCII中的表示方式相同。  
> ***ISO 10646***：ISO 10646是一个由国际标准化组织（ISO）定义的字符集，其目标与Unicode相同，即为世界上的每种语言的每个字符分配一个唯一的数字。实际上，Unicode和ISO 10646现在已经被同步，即它们分配给字符的码点是相同的。
> 总的来说，Unicode和ISO 10646定义了字符和数字之间的映射，而UTF-8和ASCII则定义了如何将这些数字编码为字节序列。

### 宽字符类型

- `char`在默认情况下**既不是有符号也不是无符号的**，是否有符号由编译器决定以便与硬件属性匹配。*例如，对于某些硬件，使用无符号字符可能更有效率。而对于其他硬件，使用有符号字符可能更合适*。（除非显式设置为`signed`或`unsigned`）
- `wchar_t`是一种**宽字符类型**（占用两个字节），它可以用来存储大多数机器的扩展字符集中的字符。*它的确切大小是与实现相关的，但是它至少与`char`一样大*。

```C++
#include <iostream>
int main()
{
    wchar_t bob = L'P';//L前缀指示宽字符常量和宽字符串
    std::wcout << bob << std::endl;//输出P
}
```

`cin`和`cout`将输入输出看作是字符流，而不是字节流。因此，它们使用`wchar_t`类型的`wcin`和`wcout`对象来处理宽字符。*`wcin`和`wcout`对象的行为与`cin`和`cout`对象的行为相同，只是它们使用`wchar_t`类型的数据*。

- char16_t：用于存储UTF-16编码的字符，占用两个字节。
- char32_t：用于存储UTF-32编码的字符，占用四个字节。

```C++
#include <iostream>
int main()
{
    char16_t bob = u'P';//u前缀指示UTF-16字符常量和字符串
    std::cout << bob << std::endl;//输出P
    char32_t bob2 = U'P';//U前缀指示UTF-32字符常量和字符串
    std::cout << bob2 << std::endl;//输出P
}
```

## 定点表示法和浮点表示法

在C++中，定点表示法和浮点表示法是两种不同的方式来显示浮点数。

- **定点表示法（Fixed Point Notation）**：在定点表示法中，小数点的位置是固定的。例如，数字123.456在定点表示法中就是"123.456"。这种表示法适合于小数点后的位数较少的情况。

- **浮点表示法（Floating Point Notation）**：在浮点表示法中，小数点的位置是可以移动的，通常用于表示非常大或非常小的数。例如，数字123456000.0在浮点表示法中可以表示为"1.23456e+08"，这里的"e+08"表示10的8次方。

`cout.setf(ios_base::fixed, ios_base::floatfield);`这行代码设置了`cout`对象的格式标志，使得浮点数以定点表示法输出，而不是默认的浮点表示法，小数点后的位数将根据设置的精度来决定。

## 类型转换

将两个`long`值相加涉及到的硬件编译指令可能会与两个`short`值相加不同。有11种整型和3种浮点类型，因此，C++提供了一种机制，用于将一种类型的值转换为另一种类型的值。这种机制称为 ***类型转换（type conversion）或强制类型转换（type casting）*** 。

- 将一种算术类型的值赋给另一种算术类型的变量时，C++将对值进行转换。*例如，将`int`值赋给`double`变量时，C++将`int`值转换为`double`值*。
- 当表达式中包含不同的类型时，C++将对值进行转换。*例如，将`int`值和`double`值相加时，C++将`int`值转换为`double`值*。
- 将参数传递给函数时，C++将对值进行转换。*例如，将`int`值传递给接受`double`参数的函数时，C++将`int`值转换为`double`值*。
![潜在的数值转换问题](..\code_picture\潜在的数值转换问题.png)

---

### 以{}方式初始化时进行的转换（C++）

  列表初始化对类型转换的要求更严格，不允许缩窄(narrowing)。例如：不允许将浮点转换为整型，不允许将长整型转换为整型。*但是允许将整型转换为浮点，允许将整型转换为长整型*，***条件是编译器知道目标变量能够正确地存储源值***。

```C++
#include <iostream>
int main()
{
    const int code=5;
    int x=5;
    int a = 3.14;//允许
    int b{3.14};//不允许
    int c = {3.14};//不允许
    int d = {code};//允许
    char e{x};//不允许窄化转化，int范围比char大（C语言允许窄转化）
    char f{24};//允许
    return 0;
}
```

### 表达式中的转换

C的整型算术运算总是至少以缺省整型类型的精度来进行的。  
为了获得这个精度，**表达式中的字符和短整型操作数在使用之前被转换为普通整型**，这种转换称为 ***整型提升*** 。

- 如果 char，short 或者 bool 类型的表达式被用在需要 int 类型的地方，那么这些类型的值会被提升为 int 类型。

- 如果 unsigned char 或者 unsigned short 的值可以被 int 类型表示，那么这些类型的值也会被提升为 int 类型。否则，它们会被提升为 unsigned int 类型。

![整型提升](..\code_picture\整型提升.png)  
[整型提升](https://blog.csdn.net/qq_39208237/article/details/109503755?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170213342116800211550161%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170213342116800211550161&biz_id=0&spm=1018.2226.3001.4187)

> 空间大又不是不能存储字节数少的数据。是的，话没错，能存，但问题在于我是4个字节的空间（大房间里有四个小房子），你是少于4个字节的数据（不能完全占据整个大房间），我到底该把你安排在哪个小房间里？我把你随便放进去的话，我要用你时又要在4个小房间里查找你到底在哪些房间里，这样势必会让我的效率变低。所以，你在住进来时，不好意思，你至少得把自己变成4个字节的，我再把你直接放进去，用你时我也不用查你在哪，我找到大房间就找到了你。  
可能这会有人会问，那我多于4个字节怎么办？不要担心，你多于4个字节，大不了我给你再安排一间大房子，你一个人住两间总该够了。***在64位平台，C语言非自定义数据类型的字节数只有4种（1,2,4,8）***。两间大房子妥妥把你舒舒服服住好喽！

```C++
#include <iostream>
int main() {
    char a = 'A';
    int b = a + 1; // 这里的 'A' 被提升为 int 类型，然后进行加法运算
    std::cout << b << std::endl; // 输出 66
    return 0;
}
```

总而言之，类型转换都是为了**尽可能不丢失精度**（长度短的被隐式转换为长度长的，较小的类型被转换为较大的类型）

### 强制类型转换

- 通用格式如下：
  
 ```c++
(typeName) value;//来自C语言
typeName (value);//纯粹的C++语法
```

（特定于C++的强制类型转换符将在后续介绍）

## C++11中的auto声明

- `auto`声明让编译器通过初始值来推算变量的类型，但是auto定义的变量必须有初始值。
- `auto`声明的变量必须马上初始化，因为编译器必须知道变量的类型。

```c++
auto n = 100;//n是int类型
auto x = 1.5;//x是double类型
auto y = 1.3e12L;//y是long double类型
auto z = 1.3e12;//z是double类型
auto w = 1.3e12f;
```

(有点像python中的变量声明)

## 为什么 C++ 中提倡尽量避免使用宏 #define（转）

[为什么 C++ 中提倡尽量避免使用宏 #define（转）](https://blog.csdn.net/zcc1229936385/article/details/110070254)

```c++
#define LEN 10 //不推荐在C++中使用宏定义
const int len = 10; //推荐使用const常量
```

## 结构体（只介绍与C的区别）

声明结构变量省略`struct`关键字，但是在C中必须加上`struct`关键字。

```c++
struct Info
{
    int age;
    char name[20];
}
struct Info c_style;
Info cpp_style;
```

列表初始化，等号可选

```c++
struct Info c_style = {18, "Bob"};
Info cpp_style {18, "Bob"};
```

将成员指定为类对象

```c++
struct Info
{
    int age;
    std::string name;
}
```

可以有成员函数

```c++
struct Info
{
    int age;
    std::string name;
    void show();
}
void Info::show()
{
    std::cout << name << " is " << age << " years old." << std::endl;
}
```

## 指针与C++基本原理（摘自C++ primer plus）

> 面向对象编程与传统的过程性编程的区别在于，OOP强调的是在 ***运行阶段*** （而不是**编译阶段**）进行决策。运行阶段指的是程序正在运行时，编译阶段指的是编译器将程序组合起来时。*运行阶段决策就好比度假时，选择参观哪些景点取决于天气和当时的心情；而编译阶段决策更像不管在什么条件下，都坚持预先设定的日程安排*。  
> 运行阶段决策提供了灵活性，可以根据当时的情况进行调整。例如，考虑为数组分配内存的情况。传统的方法时声明一个数组。要在C++中声明一个数组，必须指定数组的长度。因此数组长度在程序编译时就设定好了；这就是 ***编译阶段决策*** 。您可能认为，在80%的情况下，一个包含20个元素的数组足够了，但程序有时需要处理200个元素。为了安全起见，使用了一个包含200个元素的数组，但是在大多数情况下浪费了内存。OOP通过将这样的决策推迟到运行阶段进行，使程序更灵活。在程序运行后，可以这次告诉它只需要20个元素，而还可以下次告诉它需要200个元素。  
> 总之，使用OOP时，您可能在运行阶段确定数组的长度。为使用这种方法，语言必须在程序运行时创建数组。*C++采用的方法是，使用关键字`new`请求正确数量的内存以及使用指针来跟踪新分配的内存的位置*。  
> 在运行阶段做决策并非OOP独有的，但使用C++编写这样的代码比使用C语言简单。

```c++
int *pt;//C的写法，强调*pt是一个int类型的值
int* pt;//C++的写法，强调*pt是一种类型————指向int的指针
```

实际上以上两种对于编译器都是一样的，在哪里添加空格都行，甚至可以写作`int*p`。

## sizeof()对于数组和指针的区别

```c++
int a[10];
int *p = a;
cout << sizeof(a) << endl;//40
cout << sizeof(p) << endl;//8
```

`sizeof()`对于数组返回的是数组的大小，对于指针返回的是指针的大小,即使指针指向的是一个数组，**这种情况下，C++不会把数组名解释为地址**。

## 关于对二维数组名的理解

```c
#include <stdio.h>
#include <stdlib.h>
void print(int (*arr)[2])//错误写法：int **arr
{
    for (int i = 0; i < 10; i++)
    {
        printf("%d\n", (*arr)[i]);
    }
}
int main()
{
    int arr[5][2] = {1,2,3,4,5,6,7,8,9,10};
    for (int i = 0; i < 10; i++)
    {
        printf("%d\n", (*arr)[i]);
    }
    print(arr);
    return 0;
}
```

二维函数数组名**不是一个二级指针**，而是一个指向一维数组的指针，所以`(*arr)[i]`才能输出正确的值。

## 数组的地址

***对数组取地址时，数组名也不会被解释为其地址***。  
数组名被解释为其第一个元素的地址，而对数组名应用地址运算符时，得到的是整个数组的地址

```c++
short tell[10];
cout << tell << endl;//类型是short*
cout << &tell << endl;//类型是short(*)[10]
```

从数值上说，这两个地址相同；但从概念上说，`&tell[0]`(即tell)是一个2字节内存块的地址，而&tell是一个20字节内存块的地址。因此，表达式`tell+1`将地址加2，而`&tell+1`将地址加20。  

*可作类比：你的居住地在某个街道上，你的地址是街道的地址，你的小区的地址也是街道的地址。*

## 对于strncpy的补充

如果该函数在到达字符串结尾之前，目标内存已经用完，则它将**不会添加空字符**，因此应该这样使用该函数：

```c++
strncpy(parr,"how to use strncpy correctly",sizeof(parr)-1);
parr[sizeof(parr)-1] = '\0';
```

## 存储类型

- `auto`：自动存储类别，用于定义局部变量，是所有局部变量的默认存储类别。  
  自动变量通常存储在 ***栈*** 中。执行代码块时，其中的变量将被依次加入到栈中，当退出代码块时，这些变量将从栈中弹出。这被称为**先入后出（FILO）**的顺序。
- `static`：两种方式定义1.在函数外面定义它，若加上`static`，则使其从具有外部链接到具有内部链接；2.函数内部声明变量时加上`static`。
- `register`：用于定义存储在寄存器中而不是RAM中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的`&`运算符（因为它没有内存位置）。  
  `register int miles;`
- 动态存储：用于定义在程序执行期间可以扩展或缩减的局部变量。  
  `int *p = new int;`  
  `delete p;`  
  被分配的内存位于 ***堆*** 中，这是一种用于编程时进行内存分配的通用内存池。与栈不同，程序员负责在程序中的适当位置释放堆内存。如果程序员不这样做，这块内存将在程序结束时自动释放。

## 文件流

### 理解inFile >> value的结果为inFile

> 在C++中，`>>` 是一个运算符，被称为 "提取运算符" 或 "输入运算符"。它用于从输入流（如 `cin` 或 `ifstream` 对象）读取数据。  
> 当你写 `inFile >> value`，你是在告诉程序从 `inFile` 输入流读取数据，并将读取的数据存储在 `value` 变量中。  
> `>>` 运算符的一个特性是它返回的是其 ***左侧的操作数*** ，也就是说，表达式 `inFile >> value` 的结果是 `inFile`。这使得你可以连续使用 `>>` 运算符从同一个输入流读取多个值，如 `inFile >> value1 >> value2 >> value3`。  
> 这个特性也使得你可以在 if 语句或 while 循环中使用 >> 运算符来检查读取操作是否成功。例如，你可以写 `if (inFile >> value)` 或 `while (inFile >> value)`。如果读取操作成功，`inFile` 在布尔上下文中被视为 `true`，否则被视为 `false`。

### 理解if(!inFile)的合理性

> `if (!inFile)` 的意思是 "如果 `inFile` 为 `false`"，则执行 if 语句中的代码。

- 文件流对象可以被转换为`void*`类型，这种转换的结果是一个空指针，如果文件流对象是有效的，则转换结果为`false`，否则为`true`。
- 该对象在布尔上下文中的值是由其**状态**确定的，这个状态可以通过`good(),bad(),fail(),eof()`等函数来查询。
- `good()`：如果流成功打开，并且没有遇到任何错误（包括EOF和IO错误），则返回 true。
- `bad()`：如果在读写过程中发生硬件错误，或者严重的系统级错误（如磁盘空间不足），则返回 true。
- `fail()`：如果一个输入操作失败（例如，试图将一个字母赋值给一个整数类型的变量），则返回 true。
- `eof()`：如果文件指针到达文件的末尾，则返回 true。

## 引用和指针的区别

- 引用必须在定义时初始化，指针可以在任何时候初始化。

```c++
int a = 1;
int &b = a;//正确
int *c = &a;//正确
int &d;//错误
```

- 引用初始化后不能改变，指针可以改变所指向的对象。

```c++
int a = 1;
int b = 2;
int &c = a;
int *d = &a;
c = b;//a的值变为2，而不是将c作为b的别名，就相当于a=b；可类比代码int *const pr=&a;
```

- 指针是一个存储内存地址的实体，而引用只是某块内存的别名。所以程序为指针变量分配内存，而引用不需要分配内存。
- 没有空引用，但有空指针。这使得使用引用的代码效率比使用指针的更高。因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是被测试，防止其为空。
- 对引用使用“sizeof”得到的是变量的大小，对指针使用“sizeof”得到的是变量的地址的大小。
- 理论上指针的级数没有限制，但引用只有一级。即不存在引用的引用，但可以有指针的指针。

```c++
int **p;//正确
int &&q;//错误
```

- 指针和引用的自增（++）运算意义不同。指针的自增是指针加上它所指向类型的字节数，而引用的自增是引用所指向的变量加1。

## 为什么对于常量引用可以绑定到临时对象

```c++
void swap(int &a, int &b)
{
    int temp = a;
    a = b;
    b = temp;
}
```

进行如下操作：

```c++
long a = 1,b = 2;
swap(a,b);
```

编译器将创建两个**临时变量**，将它们初始化为a和b的值，然后将这两个**临时变量传递给swap函数**。这样做的原因是，swap函数的参数是引用，而不是指针，因此必须将引用绑定到对象上。  
***如果接受引用的参数的函数意图修改作为参数传递的变量，则创建临时变量将阻止意图的实现（类似于按值传递）***

因此，对于常量引用可以绑定到临时对象，**因为该函数的目的只是使用参数的值，并不是要修改他们**

```c++
int main()
{
    int a;
    func(a);
}
double &func(double &a) //unsafe
{
    /*some functions*/
}
```

以上便是参数类型不匹配的情况，于是编译器将创建一个正确类型的临时变量，将a的值传递给它，使用类型转换后的临时变量来调用func函数。若最后返回的是引用，则这个**临时变量将被销毁**，而返回的引用将指向一个**不存在的对象**。  
因此在形参声明前加上`const`，可以避免这种情况。若返回引用，编译器将会报错

## 为什么返回引用

```c++
double m =sqrt(16.0);
cout << m << endl;
```

4.0被复制到一个**临时位置**，然后被复制给m，第二条语句中，值5.0被复制到一个**临时位置**，然后被传递给cout.

```c++
dup=accumulate(team,five);
cout << dup << endl;
```

如果accumulate()返回一个结构，而不是指向结构的引用，将把整个结构复制到一个**临时位置**，再将这个拷贝复制到dup中。如果结构很大，这将是低效的。但在返回值为引用时，将直接把team复制到dup中。相比于前者，这里只需复制一次。

> ***注意***：应避免返回函数终止时不再存在的引用。例如，不要返回指向局部变量的引用，因为局部变量在函数终止时被销毁。  
> 最简单的是：返回一个作为参数传递给函数的引用。

## 悬挂指针和悬挂引用（github copilot）

悬挂引用和悬挂指针都是指向已经销毁的对象的引用或指针。

- 悬挂指针：当你有一个指针指向一块内存，然后这块内存被释放或者销毁，那么这个指针就变成了悬挂指针。悬挂指针是非常危险的，因为你无法保证这块内存在你再次访问它时不会被其他数据覆盖。

```c++
int *p = new int(5);
delete p; // Now p is a dangling pointer
```

- 悬挂引用：当你有一个引用指向一个对象，然后这个对象被销毁，那么这个引用就  变成了悬挂引用。悬挂引用是非常危险的，因为你无法保证这个对象在你再次访问它时不会被其他数据覆盖。

```c++
int& func() {
    int a = 5;
    return a; // Returning a reference to a local variable
} // a is destroyed here, so the returned reference is a dangling reference
```

在这两种情况下，你都应该避免使用悬挂引用或悬挂指针，因为这可能导致程序崩溃或产生不可预测的结果。

## 静态变量的初始化

- 静态变量在程序开始时就已经初始化，而不是在程序运行时初始化。它在整个程序运行期间都存在。
- 首先，静态变量都被**零初始化**，不管程序员是否显式地初始化了它。接下来如果使用常量表达式初始化了变量，且编译器仅根据文件内容（包括被包含的头文件）就可以计算表达式，编译器将根据常量表达式初始化变量。必要时可以进行简单的计算。否则，变量将被**动态初始化**。
  
```c++
#include <cmath>
int x;
int y = 5;
long z = 10*15;
double w = asin(1.0);// 要初始化w，需要调用asin()函数，这要等到函数被链接到程序中时才能完成
```

## 说明符和限定符

### 存储说明符

- `auto`：自动存储说明符，用于定义局部变量，是所有局部变量的默认存储说明符。C++11后，`auto`用于类型推断。
- `register`：用于定义存储在寄存器中而不是RAM中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的`&`运算符（因为它没有内存位置）。C++11中，`register`只是显式地指出变量是自动的。
- `static`用于全局变量表示其具有内部链接，用于局部变量表示其存储持续性为静态的。
- `extern`是引用声明，用于提供一个全局变量的引用声明，而不是定义它。*作用于函数时可以省略*  

```c++
extern int a;//声明
void foo();
extern void foo();//与上面的等价
```

- `thread_local`：C++11新增，指出变量持续性与其所属的线程相同。相当于`static`的线程版本。
- `mutable`：用于类的成员变量，表示该变量可以在`const`成员函数中被修改。

```c++
struct function
{
    mutable int a;
    int b;
}
int main()
{
    const function test;
    test.a = 1;//合法，test.a是可变的
    test.b = 1;//不合法
}
```

### CV限定符

- `const`：用于声明只读变量，或者用于声明只读成员函数。*作用于指针时，表示指针指向的对象是只读的*。***在c++中，全局const定义就像使用了static说明符一样。考虑：头文件中定义的const变量被多个源文件包含，若其具有外部链接，根据单定义规则将会导致重复定义。使用extern关键字可以覆盖默认的内部链接属性***

```c++
const int a = 1;//内部链接
extern const int b = 1;//外部链接
```

- `volatile`：表明即使**程序未对变量进行修改，变量的值也可能发生变化**（*硬件可能修改其中内容*）。该关键字是为了防止编译器对变量进行优化。*例如，假设编译器程序在几条语句中两次使用某个变量的值，可能不会查找这个值两次，而是使用寄存器中缓存的值，前提是假设该值不会发生变化*，关键字告诉编译器不要使用这种优化。  
下面是volatile变量的几个例子：

 1. 并行设备的硬件寄存器（如：状态寄存器）
 2. 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
 3. 多线程应用中被几个任务共享的变量

## 语言链接性

- `extern "C"`：用于指定C语言链接性，告诉编译器按照C语言的规则进行链接。*C++编译器会对函数名进行修饰，而C语言不会*。  
  例如，C++编译器会将`void func(int a)`编译为`_func@4`，而C语言编译器会将`void func(int a)`编译为`_func`。  
  通常用于C++调用C语言函数。

```c++
extern "C" void func(int a); // 不能再使用C++的重载特性，应按照C的规则进行链接
extern void func(int a); // 仍然可以使用C++的重载特性
extern "C++" void func(int a); //显式地指出函数是C++的
```

**这在你需要在 C++ 代码中调用 C 语言编写的函数时非常有用。**

## C++名称空间

### 传统的C++名称空间

- **声明区域**：可以在其中声明的区域。*例如：在函数外部声明全局变量，其声明区域为其声明所在的文件。在函数中声明的变量，其声明区域为其声明所在的代码块。*
- **潜在作用域**：变量的作用域从声明点开始，到其声明区域的末尾。潜在作用域比声明区域小，是由于变量必须被定义后才能使用。

> ***注意***：变量并非在潜在作用域的任何位置都是可见的，会出现被另一个嵌套声明区域中的同名变量所遮蔽的情况。变量对程序可见的范围被称为作用域
![声明区域和潜在作用域](..\code_picture\声明区域和潜在作用域.jpg)

### 新的名称空间特性

定义一种带有名称的声明区域，用于避免名称冲突。名称空间的声明形式如下：

```c++
namespace name
{
    // code
}
```

名称空间的声明区域是全局的（除非它引用了常量），因此名称空间可以跨越多个文件。名称空间的声明区域可以包含变量、函数、类等。名称空间的声明区域可以嵌套。

> ***注意***：C++中常量的链接性可以是外部的，但对于常量引用，情况有些不同。C++的常量默认都是内部链接的，它们只在定义它们的文件中可见。但是，如果你想在多个文件中共享常量，你可以使用`extern`关键字。
>
> ```c++
> extern const int a = 1;//外部链接
> ```
>
> 由于引用不占用空间，它只是别名，所以它**没有链接性**。如果你试图在一个文件中定义一个常量引用，并在另一个文件中声明它，你会遇到问题，因为引用必须在定义时初始化，这个初始化只能在定义的文件中完成。

### 全局名称空间

C++程序中的所有名称都在全局名称空间中。全局名称空间没有名称，因此不能使用`using`声明来引用它。全局名称空间中的名称可以通过作用域解析运算符`::`来访问。

```c++
#include <iostream>

// 在全局名称空间中定义一个变量
int globalVar = 10;

int main() {
    // 访问全局名称空间中的变量
    std::cout << "Global variable: " << globalVar << std::endl;
    return 0;
}
```

> ***注意***：简单来说，名称空间本质上就是对声明区域的划分。

![using声明和using编译指令的比较](..\code_picture\using编译指令和using声明的比较.png)

## C++中的类

类是一种将抽象转换成用户定义的C++工具，它将**数据表示和操纵数据**的方法组合在一起。类的定义包括**数据成员**和**成员函数**。数据成员表示类的数据，成员函数表示类的操作。
> ***注意***：类的定义只是一个模板，它本身并不占用内存。只有在创建类的对象时，内存才会被分配。  
> 一般来说：类的规范由两个部分组成：类声明和类定义。
>
> - 类声明：以数据成员的方式描述数据部分，以成员函数的方式描述公有接口。
> - 类方法定义：描述如何实现类声明中描述的接口。

### 访问控制

- `public`：类的成员在类的外部可以被访问。
- `private`：类的成员在类的外部不可以被访问，只有类的成员函数可以访问。
这体现了**封装**的思想，即将数据和操作数据的方法组合在一起，数据被隐藏在类的内部，只有类的成员函数可以访问。

> ***注意***：类和结构的唯一区别是默认的访问控制。类的默认访问控制是`private`，而结构的默认访问控制是`public`。

![访问控制](..\code_picture\访问控制.png)

### 什么时候调用析构函数

- 静态存储类型：在程序结束时调用。
- 自动存储类型：程序执行完代码块（所处块作用域）时调用。
- 对象是通过`new`创建的：在对象被`delete`时调用。
- 临时对象：在表达式结束时调用。

### 类作用域

在类中定义的名称（如类数据成员名和类成员函数名）的作用域都为整个类，作用域为整个类的名称只在该类中是已知的，在类外是不可知的。因此，可以在不同类中使用相同的类成员名而不会引起冲突。例如，Stock类的shares成员不同于JobRide类的shares成员。另外，类作用域意味着不能从外部直接访问类的成员，公有成员函数也是如此。也就是说，要调用公有成员函数，必须通过对象

### 作用域为类的常量

类声明中定义一个所有对象共享的常量时，下面的方式是错误的：（因为声明只提供了类的形式，并没有进行实例化）

```c++
class Stock
{
    const int Months = 12;
    int sales[Months];//错误
}
```

以下是正确的方式：

```c++
class Stock
{
    static const int Months = 12; // 该常量将与其他静态变量存储在一起，而不是存储在对象中。因此，只有一个Months常量，被所有Bakery对象共享。
    int sales[Months];
}
```

或者使用枚举

```c++
class Stock
{
    enum {Months = 12}; // 枚举，它的值在编译时就确定了，因此可以用来定义数组的大小
    int sales[Months];
}
```

它们的共同特点都是在**编译时**就确定了，因此可用作常量。

### 运算符重载的限制

1. 操作数至少有一个是用户定义的类型。防止用户对标准类型的操作进行重载。
2. 不能创建新的运算符。
3. 不能违反运算符原来的优先级和句法类型。
4. 不能重载的运算符：`sizeof`、`.`、成员指针运算符`.*`、`::`、`?:`、`typeid`、`const_cast`、`dynamic_cast`、`reinterpret_cast`、`static_cast`。
