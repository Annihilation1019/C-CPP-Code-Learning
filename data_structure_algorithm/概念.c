/*大O表示法：大O表示法（Big O notation）是一种用于描述算法复杂度的数学符号。它描述的是算法的最坏情况下的时间复杂度或空间复杂度。n是输入大小，时间(运行时间)/空间(所需的内存空间)复杂度为O(n)则说明输入大小翻倍时，复杂度也翻倍。二分查找法的复杂度是O(log n)，即输入大小为n时至多进行log n次操作
  一些常见的大O运行时间：O(log n)对数时间——二分查找 O(n)线性时间——简单查找 O(n!)阶乘时间——旅行商问题 O(n*n)——选择排序
  #算法的速度指的并非时间，而是操作数的增速，即数据规模对算法时间影响的描述
  #谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。
  #算法的运行时间用大O表示法表示。
  #O(log n)比O(n)快，当需要搜索的元素越多时，前者比后者快得越多。
  #算法运行时间并不以秒为单位。
  #算法运行时间是从其增速的角度度量的。*/
  
//数组：随机访问 链表：顺序访问
/*在递归函数中，基线条件（Base Case）和递归条件（Recursive Case）是两个非常重要的概念。
#基线条件：这是递归结束的条件，也就是说，当满足这个条件时，函数会停止调用自己，开始返回结果。没有基线条件的递归函数会无限递归下去，导致栈溢出。
#递归条件：这是函数继续调用自己的条件，每次调用时，都会将问题规模减小，直到满足基线条件。*/

// 调用栈：
/*调用栈（Call Stack）是一个抽象数据类型，用于存储程序执行中的函数调用信息。每当一个函数被调用时，都会在调用栈上创建一个新的栈帧（调用栈中的一个元素）（Stack Frame）。这个栈帧包含了函数的参数、局部变量以及返回地址等信息。
当函数执行完毕，其对应的栈帧就会被从调用栈中移除，程序的控制权就会返回到调用该函数的代码位置（即返回地址）。这种后进先出（LIFO）的特性使得栈特别适合用于管理函数调用。*/

/*D&C(divide and conquer)分而治之的解决思路
  1.找出基线条件，这种条件尽可能简单
  2.将问题不断拆解，知道符合基线条件*/