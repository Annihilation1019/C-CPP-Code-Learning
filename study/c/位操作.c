#include <stdio.h>
#include <stdlib.h>
char *itobs(int n, char *str);
char *itobs(int n, char *str);

struct // 位字段
{
    unsigned int is_keyword : 1; // 1位
    unsigned int is_extern : 1;  // 1位
    unsigned int is_static : 1;  // 1位
    unsigned int : 5;            // 5位，用于填充
} bits;

int main()
{
    // 1.二进制反码或按位取反(一元运算符~把1变为0，把0变为1)
    int val = 3;
    printf("val的二进制反码是%d\n", ~val); //~(00000011)=(11111100)=-4
    // 2.按位与：&(逐位比较两个运算对象，生成一个新值。对于每位，只有两个运算对象中相应位都是1时，结果才为1，否则为0)
    int a = 13, b = 7;
    printf("a&b=%d\n", a & b); //(00001101)&(00000111)=(00000101)=5
    // 3.按位或：|(逐位比较两个运算对象，生成一个新值。对于每位，只要两个运算对象中相应位有一个1时，结果就为1，否则为0)
    printf("a|b=%d\n", a | b); //(00001101)|(00000111)=(00001111)=15
    // 4.按位异或：^(逐位比较两个运算对象，生成一个新值。对于每位，如果两个运算对象中相应位不同，结果就为1，否则为0)
    printf("a^b=%d\n", a ^ b); //(00001101)^(00000111)=(00001010)=10

    // 用法：
    // 1.掩码(用于提取一个字节中的某些位，可以这样类比：把掩码中的0看作不透明，1看作透明，flag&mask相当于用掩码覆盖在flags上，透明的部分保留，不透明的部分清零)
    int flag = 150;                                    //(10010110)
    int mask = 2;                                      //(00000010)
    printf("flag与掩码结合后的值是%d\n", flag & mask); //(10010110)&(00000010)=(00000010)=2

    // 2.打开位(设置位，可以理解位：把open中的1看作打开信号，0看作无信号，flag|open相当于把open中的1打开，无信号的部分保持不变)
    int open = 96;                                 //(01100000)
    printf("flag打开位的结果是%d\n", flag | open); //(10010110)|(01100000)=(11110110)=246，将flag的第5、6位打开

    // 3.关闭位(清除位，可以理解为：把close中的1看作关闭信号，0看作无信号，flag&~close相当于把close中的1关闭，无信号的部分保持不变)
    int close = 2;                                   //(00000010)将期望关闭的位设为1，其余位设为0
    printf("flag关闭位的结果是%d\n", flag & ~close); //(10010110)&(11111101)=(10010100)=148，将flag的第1位关闭

    // 4.切换位(切换位，1^0=1,1^1=0，可理解为：1是切换信号)
    int toggle = 3;                                  //(00000011)将期望切换的位设为1，其余位设为0
    printf("flag切换位的结果是%d\n", flag ^ toggle); //(10010110)^(00000011)=(10010101)=149，将flag的第0、1位切换

    // 5.检查位的值(flag的位是否被设置为1？)
    int check = 2;             //(00000010)将期望检查的位设为1，其余位设为0
    if ((flag & mask) == mask) // 用掩码mask检查flag的第1位是否被设置为1
    {
        puts("flag的第1位被设置为1了");
    }

    // 移位运算符
    //  1.左移运算符<<
    int c = 13;
    printf("c<<2=%d\n", c << 2); //(00001101)<<2=(00110100)=52

    // 2.右移运算符>>
    int d = 25;
    printf("d>>3=%d\n", d >> 3); //(00011001)>>3=(00000011)=3

    // 用法：移位运算符针对2的次幂提供快速有效的乘法和除法

    // 位操作的应用：转换二进制
    char *p = (char *)malloc(100 * sizeof(char));
    int n;
    printf("请输入一个整数：");
    scanf("%d", &n);
    puts(itobs(n, p));

    // 位字段
    // 位字段是一种数据结构，用于存储一组位，可以用来表示各种属性，是一种更紧凑的存储数据的方式
    bits.is_extern = 1;
    bits.is_keyword = 0;
}

char *itobs(int n, char *str)
{
    static int size = 8 * sizeof(int);
    for (int i = size - 1; i >= 0; i--, n >>= 1) // 按位分析整数
    {
        str[i] = (01 & n) + '0'; // 把01和n进行按位与运算，结果为1则str[i]为'1'，否则为'0'，+ '0'是为了把数字转换为字符
    }
    str[size] = '\0';
    return str;
}